# coding: utf-8

"""
    REST API Mapy.cz routing methods

    Service for finding/planning a route between two or more points.   Api is based on common principles described in the document [Common principles of REST API Mapy.cz](/v1/docs/commons/)

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import warnings

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Dict, List, Optional, Tuple, Union, Any

try:
    from typing import Annotated
except ImportError:
    from typing_extensions import Annotated

from pydantic import Field
from typing_extensions import Annotated
from typing import Any, Optional

from mapy_cz_routing.models.response_basic_route_v1_routing_route_get import ResponseBasicRouteV1RoutingRouteGet

from mapy_cz_routing.api_client import ApiClient
from mapy_cz_routing.api_response import ApiResponse
from mapy_cz_routing.rest import RESTResponseType


class RoutingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def basic_route_v1_routing_route_get(
        self,
        start: Annotated[Any, Field(description="Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format.")],
        end: Annotated[Any, Field(description="Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format.")],
        route_type: Annotated[Any, Field(description="Route type")],
        lang: Annotated[Optional[Any], Field(description="Language")] = None,
        format: Annotated[Optional[Any], Field(description="Output geometry format")] = None,
        avoid_toll: Annotated[Optional[Any], Field(description="Avoid sections where tolls are paid")] = None,
        waypoints: Annotated[Optional[Any], Field(description="Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResponseBasicRouteV1RoutingRouteGet:
        """Basic Route

        Service for finding/planning a route between two points, optionally via up to fifteen waypoints. The result of the planner call is the length of the found route, the estimated duration according to the selected mode of transport and the geometry of the route in the selected format. If it is not possible to plan the route for the selected mode of transport, the service will return http response code ``404``. The cause of the error is described in the response body: ```json { \"detail\": [     {         \"msg\": \"Edge not found\",         \"errorCode\": 7,     }     ] } ``` ### Possible routing errors: * ``errorCode: 7`` - the route point is outside the available route network for the selected type of transport. * ``errorCode: 9`` - the route point is located in an area to which is not connected by the selected mode of transport. For example, another continent.

        :param start: Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format. (required)
        :type start: object
        :param end: Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format. (required)
        :type end: object
        :param route_type: Route type (required)
        :type route_type: RouteType
        :param lang: Language
        :type lang: Language
        :param format: Output geometry format
        :type format: GeometryFormat
        :param avoid_toll: Avoid sections where tolls are paid
        :type avoid_toll: object
        :param waypoints: Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.
        :type waypoints: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._basic_route_v1_routing_route_get_serialize(
            start=start,
            end=end,
            route_type=route_type,
            lang=lang,
            format=format,
            avoid_toll=avoid_toll,
            waypoints=waypoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseBasicRouteV1RoutingRouteGet",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "RoutingErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def basic_route_v1_routing_route_get_with_http_info(
        self,
        start: Annotated[Any, Field(description="Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format.")],
        end: Annotated[Any, Field(description="Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format.")],
        route_type: Annotated[Any, Field(description="Route type")],
        lang: Annotated[Optional[Any], Field(description="Language")] = None,
        format: Annotated[Optional[Any], Field(description="Output geometry format")] = None,
        avoid_toll: Annotated[Optional[Any], Field(description="Avoid sections where tolls are paid")] = None,
        waypoints: Annotated[Optional[Any], Field(description="Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResponseBasicRouteV1RoutingRouteGet]:
        """Basic Route

        Service for finding/planning a route between two points, optionally via up to fifteen waypoints. The result of the planner call is the length of the found route, the estimated duration according to the selected mode of transport and the geometry of the route in the selected format. If it is not possible to plan the route for the selected mode of transport, the service will return http response code ``404``. The cause of the error is described in the response body: ```json { \"detail\": [     {         \"msg\": \"Edge not found\",         \"errorCode\": 7,     }     ] } ``` ### Possible routing errors: * ``errorCode: 7`` - the route point is outside the available route network for the selected type of transport. * ``errorCode: 9`` - the route point is located in an area to which is not connected by the selected mode of transport. For example, another continent.

        :param start: Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format. (required)
        :type start: object
        :param end: Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format. (required)
        :type end: object
        :param route_type: Route type (required)
        :type route_type: RouteType
        :param lang: Language
        :type lang: Language
        :param format: Output geometry format
        :type format: GeometryFormat
        :param avoid_toll: Avoid sections where tolls are paid
        :type avoid_toll: object
        :param waypoints: Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.
        :type waypoints: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._basic_route_v1_routing_route_get_serialize(
            start=start,
            end=end,
            route_type=route_type,
            lang=lang,
            format=format,
            avoid_toll=avoid_toll,
            waypoints=waypoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseBasicRouteV1RoutingRouteGet",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "RoutingErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def basic_route_v1_routing_route_get_without_preload_content(
        self,
        start: Annotated[Any, Field(description="Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format.")],
        end: Annotated[Any, Field(description="Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format.")],
        route_type: Annotated[Any, Field(description="Route type")],
        lang: Annotated[Optional[Any], Field(description="Language")] = None,
        format: Annotated[Optional[Any], Field(description="Output geometry format")] = None,
        avoid_toll: Annotated[Optional[Any], Field(description="Avoid sections where tolls are paid")] = None,
        waypoints: Annotated[Optional[Any], Field(description="Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Basic Route

        Service for finding/planning a route between two points, optionally via up to fifteen waypoints. The result of the planner call is the length of the found route, the estimated duration according to the selected mode of transport and the geometry of the route in the selected format. If it is not possible to plan the route for the selected mode of transport, the service will return http response code ``404``. The cause of the error is described in the response body: ```json { \"detail\": [     {         \"msg\": \"Edge not found\",         \"errorCode\": 7,     }     ] } ``` ### Possible routing errors: * ``errorCode: 7`` - the route point is outside the available route network for the selected type of transport. * ``errorCode: 9`` - the route point is located in an area to which is not connected by the selected mode of transport. For example, another continent.

        :param start: Coordinates of the beginning of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?start=14.40094&start=50.0711`` and unexploded ``?start=14.40094,50.0711`` format. (required)
        :type start: object
        :param end: Coordinates of the end of the route. An array of two float numbers. The first number is ``longitude``, the second is ``latitude``. Supports exploded ``?end=14.40094&end=50.0711`` and unexploded ``?end=14.40094,50.0711`` format. (required)
        :type end: object
        :param route_type: Route type (required)
        :type route_type: RouteType
        :param lang: Language
        :type lang: Language
        :param format: Output geometry format
        :type format: GeometryFormat
        :param avoid_toll: Avoid sections where tolls are paid
        :type avoid_toll: object
        :param waypoints: Up to 15 optional waypoint coordinates between start and end.  The parameter supports a semicolon-separated list of coordinates ``?waypoints=14.4009400,50.0711000;14.3951303,50.0704094``, or exploded array of coordinates ``?waypoints=14.4009400,50.0711000&waypoints=14.3951303,50.0704094``. The waypoint coordinates are two float numbers separated by a comma in the order ``longitude``, ``latitude``.
        :type waypoints: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._basic_route_v1_routing_route_get_serialize(
            start=start,
            end=end,
            route_type=route_type,
            lang=lang,
            format=format,
            avoid_toll=avoid_toll,
            waypoints=waypoints,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResponseBasicRouteV1RoutingRouteGet",
            '401': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "RoutingErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _basic_route_v1_routing_route_get_serialize(
        self,
        start,
        end,
        route_type,
        lang,
        format,
        avoid_toll,
        waypoints,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> Tuple:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if end is not None:
            
            _query_params.append(('end', end))
            
        if route_type is not None:
            
            _query_params.append(('routeType', route_type.value))
            
        if lang is not None:
            
            _query_params.append(('lang', lang.value))
            
        if format is not None:
            
            _query_params.append(('format', format.value))
            
        if avoid_toll is not None:
            
            _query_params.append(('avoidToll', avoid_toll))
            
        if waypoints is not None:
            
            _query_params.append(('waypoints', waypoints))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            [
                'application/json'
            ]
        )


        # authentication setting
        _auth_settings: List[str] = [
            'headerApiKey', 
            'queryApiKey'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/routing/route',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


